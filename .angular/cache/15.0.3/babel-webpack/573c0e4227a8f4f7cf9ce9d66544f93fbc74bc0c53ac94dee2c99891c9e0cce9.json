{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { environment } from '../environment/environment';\nimport { catchError, retry, throwError } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./event.service\";\nexport class HttpService {\n  constructor(http, event) {\n    this.http = http;\n    this.event = event;\n    this.rootUrl = environment.apiEndPoint;\n    this.baseUrl = `${this.rootUrl}/`;\n    this.showErrorMessage = message => {\n      console.log(message);\n    };\n    this.handleError = error => {\n      this.event.isHttpError.emit(error.error);\n      if (error.error instanceof ErrorEvent) {\n        // A client-side or network error occurred. Handle it accordingly.\n        console.error('An error occurred:', error.error.message);\n      } else {\n        if (error.status === 401) {\n          console.log(\"login user out\");\n        }\n        this.showErrorMessage(error.error);\n      }\n      return throwError(() => 'Something went wrong, please try again later');\n    };\n  }\n  get(url, cb) {\n    const endpoint = this.baseUrl + url;\n    this.http.get(endpoint).pipe(retry(3)\n    // catchError(this.handleError)\n    ).subscribe(data => {\n      if (data.success) {\n        cb(data);\n      } else {\n        this.showErrorMessage(data);\n      }\n    });\n  }\n  search(url, body, cb) {\n    const params = new HttpParams({\n      fromObject: body\n    });\n    const endpoint = `${this.baseUrl} + ${url}`;\n    this.http.get(endpoint, {\n      params\n    }).pipe(retry(3), catchError(this.handleError)).subscribe(data => {\n      if (data) {\n        cb(data);\n        this.showErrorMessage(data);\n      } else {}\n    });\n  }\n  post(url, body, cb) {\n    const endpoint = this.baseUrl + url;\n    this.http.post(endpoint, body).pipe(retry(0), catchError(this.handleError)).subscribe(data => {\n      if (data) {\n        cb(data);\n      } else {\n        this.showErrorMessage(data);\n      }\n    });\n  }\n  patch(url, body, cb) {\n    const endpoint = `${this.baseUrl} + ${url}`;\n    this.http.patch(endpoint, body).pipe(retry(3), catchError(this.handleError)).subscribe(data => {\n      if (data) {\n        cb(data);\n      } else {\n        this.showErrorMessage(data);\n      }\n    });\n  }\n  delete() {}\n}\nHttpService.ɵfac = function HttpService_Factory(t) {\n  return new (t || HttpService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.EventService));\n};\nHttpService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: HttpService,\n  factory: HttpService.ɵfac,\n  providedIn: 'root'\n});\nexport class AuthInterceptor {\n  constructor() {}\n  intercept(req, next) {\n    req = req.clone({\n      setHeaders: {},\n      setParams: {\n        key: \"\"\n      }\n    });\n    return next.handle(req);\n  }\n}\nAuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) {\n  return new (t || AuthInterceptor)();\n};\nAuthInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AuthInterceptor,\n  factory: AuthInterceptor.ɵfac\n});","map":{"version":3,"mappings":"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","names":["HttpParams","environment","catchError","retry","throwError","HttpService","constructor","http","event","apiEndPoint","rootUrl","message","console","log","error","isHttpError","emit","ErrorEvent","status","showErrorMessage","get","url","cb","endpoint","baseUrl","pipe","subscribe","data","success","search","body","params","fromObject","handleError","post","patch","delete","factory","providedIn","AuthInterceptor","intercept","req","next","clone","setHeaders","setParams","key","handle"],"sourceRoot":"","sources":["/Users/mac/Documents/freecodecamp/ngVGDB/src/app/services/http.service.ts"],"sourcesContent":["import { HttpClient, HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpParams, HttpRequest } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { environment } from '../environment/environment';\nimport { Observable, catchError, retry, throwError } from 'rxjs';\nimport { EventService } from './event.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class HttpService {\n\n  private rootUrl = environment.apiEndPoint;\n  private baseUrl = `${this.rootUrl}/`\n\n  constructor(private http: HttpClient, private event: EventService) { }\n\n  get(url: string, cb: any){\n    const endpoint = this.baseUrl + url\n    this.http\n      .get<ResponseObject>(endpoint)\n      .pipe(\n        retry(3)\n        // catchError(this.handleError)\n      )\n      .subscribe(data => {\n        if(data.success){\n          cb(data);\n        }else {\n          this.showErrorMessage(data);\n        }\n      })\n  }\n\n  search(url: string, body: any, cb: any){\n    const params = new HttpParams({\n      fromObject: body\n    });\n    const endpoint = `${this.baseUrl} + ${url}`;\n    this.http\n      .get(endpoint, { params })\n      .pipe(\n        retry(3),\n        catchError(this.handleError)\n      )\n      .subscribe(data => {\n        if(data){\n          cb(data);\n          this.showErrorMessage(data)\n        }else {\n          \n        }\n      });\n  }\n\n  post(url: string, body: any, cb: any){\n    const endpoint = this.baseUrl + url;\n    this.http\n      .post<ResponseObject>(endpoint, body)\n      .pipe(\n        retry(0),\n        catchError(this.handleError)\n      )\n      .subscribe(data => {\n        if(data){\n          cb(data)\n        }else {\n          this.showErrorMessage(data)\n        }\n      })\n  }\n\n  patch(url: string, body: any, cb: any){\n    const endpoint = `${this.baseUrl} + ${url}`;\n    this.http\n      .patch(endpoint, body)\n      .pipe(\n        retry(3),\n        catchError(this.handleError)\n      )\n      .subscribe((data) => {\n        if(data){\n          cb(data)\n        }else {\n          this.showErrorMessage(data);\n        }\n      });\n  }\n\n  delete(){}\n\n  private showErrorMessage = (message: any) => {\n    console.log(message);\n  }\n\n  private handleError = (error: HttpErrorResponse) => {\n    this.event.isHttpError.emit(error.error);\n    if(error.error instanceof ErrorEvent){\n      // A client-side or network error occurred. Handle it accordingly.\n      console.error('An error occurred:', error.error.message);\n    }else {\n      if(error.status === 401){\n        console.log(\"login user out\");\n      }\n      this.showErrorMessage(error.error);\n    }\n\n    return throwError(() => 'Something went wrong, please try again later')\n\n  }\n\n}\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(){}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n      req = req.clone({\n        setHeaders: {\n\n        },\n        setParams: {\n          key: \"\"\n        }\n      })\n\n      return next.handle(req);\n  }\n}\n\nexport interface ResponseObject {\n  success: boolean;\n  errorCode: number;\n  message: string;\n  user: any;\n  token: string;\n  data: any;\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}